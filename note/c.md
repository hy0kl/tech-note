# 多级指针的个人理解

```
以 char 当作书本为例子,能更形象的说明

char    p       代表书的具体一个字
char   *p       代表书的具体一行内容
char  **p       代表书的一页的内容
char ***p       代表书有多页内容,可以翻页

更多层级可以理解为 书本(换一本书)->书柜(换一个书柜) 等等.
也可以通过 点,线,面,三维立体 的具象来理解

type_t *p   指向 type_t 类型的指针
```

数组的`array[i]`和`*(array + i)`等价.

```c
int array[10] = {0};

int *p;

// 等价
p = array;
// p = &a[0];

// *(p + 2), *(array + 2), a[2], p[2] 等价
```

# 指针数组

1. 可以定义一个数组,数组中有若干个相同类型指针变量,这个数组被称为指针数组
1. 指针数组本质是个数组,是个保存指针的容器,是若干个相同类型的指针变量构成的集合

`类型 *数组名[元素个数];`

char *p[10];

# 数组指针

本质是一个指针,指向一个数组,即指向数组的指针.

`指向的数组的类型 (*指针变量)[指向的数组的元素个数]`

# 指针函数

本质是一个函数,返回值是一个指针.

# 函数指针

本质是一个指针,指向一个函数.

# 函数参数

c 语言函数参数是形式,在调用函数时,参数实例,是在栈上新分配空间,将实参的值去初始化形参.
如果想在函数内部改变外边的变量的值,需要参数实例化时取一级指针.

[例子与详解](https://github.com/hy0kl/algorithm/blob/master/other/func_args.c)

# const关键字

1、 修饰变量：

功能是对变量声明为只读特性，并保护变量值以防被修改。

```cgo
// 变量i具有只读特性，不能够被更改；若想对i重新赋值，如i = 10；则是错误的。
const int i = 5;
```

值得注意的是，定义变量的同时，必须初始化。定义形式也可以写成`int const i = 5`，同样正确。

此外，const修饰变量还起到了节约空间的目的，通常编译器并不给普通const只读变量分配空间，而是将它们保存到符号表中，无需读写内存操作，程序执行效率也会提高。

2、 修饰数组

```cgo
// 数组元素与变量类似，具有只读属性，不能被更改；一旦更改，如程序将会报错。

const int array[5] = {1,2,3,4,5};

array[0] = array[0]+1; // 错误
```

3、 修饰指针

```cgo
int i = 5;
int j = 6;
int k = 7;

const int * p1 = &i; // 定义1

// 在定义1 中const限定的是 *p1，即其指向空间的值不可改变，若改变其指向空间的值如 *p1=20，则程序会报错；但 p1 的值是可以改变的，对 p1 重新赋值如 p1=&k 是没有任何问题的。

int * const p2 =&j; // 定义2

// 在定义2 中const限定的是指针 p2，若改变 p2 的值如 p2=&k，程序将会报错；但*p2，即其所指向空间的值可以改变，如 *p2=80 是没有问题的，程序正常执行。
```

4、 修饰函数参数

const 关键字修饰函数参数，对参数起限定作用，防止其在函数内部被修改。所限定的函数参数可以是普通变量，也可以是指针变量。

```cgo
void fun1(const int i)
{
    // 其它语句

    // ……

    i++; //对i的值进行了修改，程序报错

    // 其它语句
}

void fun2(const int *p)
{
    // 其它语句

    // ……

    (*p)++; // 对p指向空间的值进行了修改，程序报错

    // 其它语句
}
```

# 移位操作溢出

[参见](http://stackoverflow.com/questions/4201301/warning-left-shift-count-width-of-type)

```
unsigned long long int t = 1 << 32;
编译时报如下错.原因是 1 是 int 型,左移 32 位溢出.
warning: shift count >= width of type [-Wshift-count-overflow]

解决方法:
unsigned long long int t = 1ULL << 32;
显式指定更宽的位数.
```

# 开发环境编译参数

```
export CFLAGS="-Wall -g"
```

# 内存泄漏工具

```
valgrind --track-origins=yes ./pro
```

# 拾遗

- 除了`sizeof`,`&`操作和声明之外,数组名称都会被编译器推导为指向其首个元素的指针.对于这些情况,不要用"是"这个词,而是要用"推导".
- `struct_obj->member`是`(*struct_obj).member`的简写.
- 不想显式释放内存又想避免内存泄漏的办法是引入`libGC`库.需要把所有的`malloc`换成`GC_malloc`,然后把所有的`free`删掉.
- '%p'占位符,打印出内存地址.
- 理清内存的最简单的方式是遵守这条原则:如果你的变量并不是从`malloc`中获取的,也不是从一个从`malloc`获取的函数中获取的,那么它在栈上.

- 关于栈和堆的主要问题:
  - 如果你从`malloc`获取了一块内存,并且把指针放在了栈上,那么当函数退出时,指针会被弹出而丢失.
  - 如果你在栈上存放了大量数据(比如大结构体和数组),那么会产生"栈溢出"并且程序会中止.
  - 如果你获取了指向栈上变量的指针,并且将它用于传参或从函数返回,接收它的函数会产生"段错误".因为实际的数据被弹出而消失,指针也会指向被释放的内存.
- 函数指针的主要用途是向其他函数传递"回调",或者模拟类和对象.
- 参数传递是值传递,普通变量将实参的值拷贝给形参,指针变量将指针变量的值拷贝给形参,没有引用的说法.

```cgo
void change(char *p)
{
    *(p + 2) = '@';
    printf("在函数中修改值: str: %s\n", p);
}

int main(int argc, char *argv[])
{
    char str[] = "hi, this is a string.";

    printf("调用函数前: str: %s\n", str);
    change(str);
    printf("调用函数后: str: %s\n", str);


    return 0;
}
```

执行结果:
```shell
./a.out
调用函数前: str: hi, this is a string.
在函数中修改值: str: hi@ this is a string.
调用函数后: str: hi@ this is a string.
```

# 指定对齐原则

使用`#pragma pack(value)`改变默认对齐原则

